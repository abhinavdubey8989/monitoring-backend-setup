
 

# 1 Aim 
The aim of this document is to practically see how StatsD , Graphite , Grafana work in symphony . They can be leveraged to provide useful & actionable insights about application servers. 

# 2 Introduction to StatsD & its Docker Setup 
StatsD is a network daemon used for collecting & aggregating metrics , over TCP or UDP , such as counters & timers, across distributed systems.

StatsD is typically implemented using Node.js, although there are also implementations available in other programming languages. 

The original implementation was developed by Etsy in Node.js

# 2.1 StatsD components 
StatsD has 3 major components

Client : an entity which creates data & delivers it to StatsD server . It could be a simple terminal command . Mostly this refers to the application-server (or host machine which we want to monitor , like server which runs nginx) which generates & sends metrics.

Server :  a daemon process responsible for listening for metric data as it’s pushed from the client, batching them & sending them to the backend.

Backend : the place where StatsD server sends/flush the data for storage . Mostly it is a time series database . We can also , optionally , flush it to terminal as well , just to see the data that is sent from StatsD server

# 2.2 StatsD Docker Setup 
To run StatsD server locally , we can use the below docker-compose.yml file.



version: '3'
services:
  statsd:
    image: statsd/statsd
    container_name: my-statsd
    tty: true
    ports:
      - "8125:8125/udp"
    volumes:
      - ./config.js:/usr/src/app/config.js
 

here we are using docker volumes to provide custom config.js . We would see different config.js examples in next sections.

# 2.3 Sending Metrics to StatsD from terminal & printing them on terminal 
To print the metric sent by StatsD server on terminal , the config.js would look like 



{
  "port": 8125,
  "flushInterval": 10000,  #flush metrics to console every 10 seconds
  "debug": true,
  "backends": ["./backends/console.js"], #tells the StatsD server to just print on terminal
  "console": {
    "prettyprint": true #prints the data in formatted manner
  }
}
 

What does ./backends/console.js mean though ?

Open
image-20240222-192647.png
If we inspect the StatsD container , the main directory is : /usr/src/app

It contains a directory called backends , where the config related to console , Graphite are present

./backends/console.js refers to use this config for printing the metrics to console

 

Now , run any 1 of the below command to start the StatsD server 



#for running in detached mode , container log will stop showing up 
sudo docker-compose up -d
#for running in attach mode , container log will keep on going & terminal can't be used further
sudo docker-compose up 
The below would be the logs generated by StatsD server . We can see that is looks like an object group by counters , timers , gauges , sets sections . These are the types of metrics which we can send to StatsD .

Open
image-20240222-150817.png
 

To send metric to the above StatsD via terminal server , we can fire the below command



echo "terminal.v1:1|c" | nc -w 1 -u localhost 8125
this would basically :

send a counter metric (denoted by |c in the above command)

name of that metric is terminal.v1 (this can be any string of preference)

the destination is 

host : localhost (host at which the StatsD listens) 

port : 8125 (port at which the StatsD listens) .

Running this command would give the below logs 

Open
image-20240222-150640.png
 

# 3 Introduction to Graphite 
Graphite is a open-source monitoring & graphing tool used to collect, store, visualize time-series data. 

# 3.1 Components of Graphite 
The 3 main components of Graphite are : 

Storage Backend (Whisper): Graphite uses Whisper as its storage backend. Whisper is a fixed-size database designed for time-series data. It stores data points at fixed intervals, enabling efficient storage & retrieval of metrics over time.

Carbon: Carbon is Graphite's built-in daemon responsible for receiving metrics data, aggregating it, & writing it to Whisper databases. It supports multiple protocols for data ingestion, including plaintext & pickle , making it compatible with a wide range of monitoring tools & systems.

Web Interface: Graphite provides a web-based user interface for data exploration & visualization. Users can create custom dashboards, graphs, & reports to monitor & analyze their metrics data.

 

# 3.2 Graphite Docker Setup & receiving metrics from StatsD 
To run Graphite locally , we can use the below docker-compose.yml file.

NOTE : the Docker image used in below file is capable of running StatsD too . However , we are using separate docker-compose files & Docker images to achieve higher segregation



version: '3'
services:
  graphite:
    image: graphiteapp/graphite-statsd
    container_name: my-graphite
    restart: always
    ports:
      - "8077:80" #Graphite web interface would be available on localhost:8077
      - "2003-2004:2003-2004"
      - "2023-2024:2023-2024"
Explanation of port mapping above :

Port range 2003-2004 allows StatsD to send Pickle-formatted metric data to Graphite.

Port 2004 is the primary port for Pickle data transmission.

Port 2003 is often used for administrative purposes.

Pickle protocol is usually used for high-volume metric data transmission due to its efficiency.

Port 2023 is typically used for plaintext UDP data transmission.

Port 2024 is used for plaintext TCP data transmission.

Plaintext protocol is easier to debug and understand, but it may be less efficient than the Pickle protocol, especially for high-volume metric data.

# 3.3 Receiving metrics from StatsD & inspecting the Graphite container for whisper files 
Till now , we used StatsD for just print the metrics to console . We can replace the previous config.js with  the below config.js file to send the same metrics to Graphite. 



{
  "port": 8125,
  "flushInterval": 10000,
  "debug": true,
  "backends": ["./backends/console.js" , "./backends/graphite.js"],
  "console": {
    "prettyprint": true
  },
  "graphiteHost": "host.docker.internal",
  "graphitePort": 2003
}
We can use the same terminal command to send the same metric again . This time along with just printing to console , the same metric would reach Graphite .

If we inspect the Graphite container : 

the data (config + metrics) related to Graphite is at the location : /opt/graphite 

the counter data is at : /opt/graphite/storage/whisper/stats_count

at the above we can see 2 directories : terminal , statsD

inside terminal directory we have : v1.wsp , this is where the counter related to terminal.v1 metric is stored (data is not in human readable form , shown below using cat command)

StatsD creates directory basis the separator , which in our case is dot(.) sign

Open
image-20240222-161914.png
# 3.4 Docker : localhost vs host.docker.internal 
in the config.json we used for StatsD server , we can see that for Graphite host , we gave the below config 



"graphiteHost": "host.docker.internal",
but the Graphite container was running on our local machine , so why is the above config not localhost ?

 When using containers, there are two commonly used methods to communicate b/w 2 services running on the host machine:

Using localhost: When you use localhost within a Docker container, it refers to the networking namespace of the container itself, not the host machine. Therefore, if a service is running on the host machine and you want to access it from within a Docker container using localhost, you might encounter connection issues because the service is not actually running within the container's networking namespace.

Using host.docker.internal: Docker provides a special DNS name host.docker.internal that resolves to the internal IP address of the host machine from within a container , without needing to know the host machine's IP address explicitly. This allows containers to access services running on the host machine by using host.docker.internal as the hostname or IP address.

 

 

Open
image-20240311-070935.png
 

# 3.5 Graphite UI 
Graphite also has a UI of its own . We had exposed port 8077 on the host for the ui , so to access the ui , visit : http://localhost:8077
When we plot the graph for counts of terminal.v1 , we get the below graph

Open
image-20240222-163548.png
 

# 4 Introduction to Grafana 
Grafana is an open-source analytics and visualization platform  

It allows users to query, visualize, and alert on time-series data from various data sources. 

Some examples of time-series db : Graphite , InfluxDB , Prometheus etc.

# 4.1 Grafana Docker Setup 
To run Grafana locally , we can use the below docker-compose.yml file.



version: '3'
services:
  Grafana:
    image: grafana/grafana:7.0.0
    ports:
      - "3000:3000"
    environment:
        - GF_SECURITY_ADMIN_PASSWORD=password #this needs to be used while loggin in
NOTE : We can use latest version of the above image as well , however here we have used 7.0.0 because that is the version we are using at <> (as of 22nd Feb 2024)

 

# 4.2 Adding Graphite as data source to Grafana 

To access Grafana on the local machine , visit http://localhost:3000

use the below credentials :

username : admin

password : password

Click on add-data-source

Select Graphite from DB options , the below screen would show up

Enter hostname as : http://host.docker.internal:8077

The above hostname points to Graphite

Open
image-20240222-164957.png
 

# 5 Using sample Nodejs servers to send metrics to StatsD 
Till now we sent the metrics from terminal & printed it on console & saw on Graphite . Now we will send the metrics programatically from a backend-service written in node.js

We need to install a StatsD client library , which is used to create & send the metric

One such library is StatsD-client & can be installed by : npm i StatsD-client

Once installed , we can create a dummy end-point which apart from serving the request , also emits the metrics 

counter-metric : 

name : server_id.api.v1.user

in this case refers to the number of times this API was called

timer-metric : 

name : server_id.api.v1.user

in this case refers to the amount of time (in millisecond) it took to process the request (hardcoded for now , as a random number b/w 5 & 10)

 

Open
image-20240222-194239.png
 

We can now dockerize the above application & run-multiple instances of it . This would simulate a backend service running in cluster

the metricPrefix variable used in above snipped is used to differentiate the metrics being generated from different containers , as each container would have different id , we could leverage that to uniquely identify metrics too.

We need to create Dockerfile & docker-compose files , shown below is the docker-compose file

 

Open
image-20240222-171406.png
Here we are running 2 instances , which run on the host port 3033 & 4033

Use the below curl requests to hit the endpoints



curl --location --request POST 'http://localhost:3033/StatsD-poc'
curl --location --request POST 'http://localhost:4033/StatsD-poc'
 

# 5.1 Inside the Graphite DB (inspecting the container & whisper files) 
The timing & counter metrics are stored separately inside the Graphite DB

The below refers to counter data

Open
image-20240222-172155.png
The below refers to timers data . Note that the statistics related to 99-percentile , 95-percentile , 90-percentile data are stored separately in whisper files

Open
image-20240222-172436.png

# 5.2 Visualising metrics on Graphite + Grafana 
We can now make API calls to the 2 virtual servers & plot various graphs on Graphite as well as Grafana . Also , Grafana provides the facility to create variables basis on regex pattern , we can use that to point to both or individual servers

Let’s say we called the API 60 times on server-1 & 40 times on server-2

Open
image-20240222-175129.png
Open
image-20240222-201026.png
 

# 6 Summary 
In summary, StatsD is used for collecting application metrics, Graphite is used for storing and visualizing time-series data, and Grafana is used for creating dashboards and visualizations to monitor and analyze metrics data from various sources. Together, they form a powerful stack for monitoring and observability in software development and operations. The below image summarises the use of the above mentioned components .

Open
image-20240222-202009.png
 

# 7 References 
Docker

 StatsD

StatsD config

Graphite functions

Grafana Playbook

Components' slide